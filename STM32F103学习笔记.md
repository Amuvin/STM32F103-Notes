<h1 align="center"> 📒 STM32F103知识整理</h1> 

## 📃 前言

* 读者可以根据自己的需要进行页面的跳转学习
* 每个知识点的最后都有**相对应的例子**
* 格式为：**先说明理论，后函数，最后例子**
* 让我们开始学习吧 🤓

## 🖊 笔记总览

> [00 - STM32F103引脚定义](# 📐 STM32F103引脚定义)
>
> [01 - GPIO控制](# 🎓 GPIO控制)
>
> [02 - 外部中断控制](# 引脚定义)
>
> [03 - TIM定时中断](# 引脚定义)
>
> [04 - 编码器接口](# 引脚定义)
>
> [05 - PWM输出](# 引脚定义)
>
> [06 - IC输入捕获](# 引脚定义)
>
> [06 - UART串口协议](# 引脚定义)
>
> [07 - IIC通信协议](# 引脚定义)
>
> [08 - SPI通信协议](# 引脚定义)
>
> [09 - ADC模数转换](# 引脚定义)
>
> [10 - DMA数据搬运](# 引脚定义)

## 📐 STM32F103引脚定义

> <img src="./STM32F103学习笔记.assets/0-1引脚定义图.png">

## 🎓 GPIO控制

#### ✏ GPIO简介

- GPIO（General Purpose Input Output）通用输入输出口
- 可配置为8种输入输出模式
- 引脚电平：**0V~3.3V**，部分引脚可容忍5V
- 输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等
- 输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

#### ✏ GPIO基本结构

- GPIO挂载在**APB2**总线上

> <img src="./STM32F103学习笔记.assets/1-1GPIO基本结构.png" width="50%">

- GPIO基本运行结构框图

><img src="./STM32F103学习笔记.assets/1-2GPIO基本结构框图.png" width="67%">

#### ✏ GPIO模式

| 模式名称       | 性质       | 特征                                     |
|----------------|------------|------------------------------------------|
| 浮空输入       | 数字输入   | 可读取引脚电平，若引脚悬空，则电平不确定 |
| 上拉输入       | 数字输入   | 可读取引脚电平，内部连接上拉电阻，悬空时默认高电平 |
| 下拉输入       | 数字输入   | 可读取引脚电平，内部连接下拉电阻，悬空时默认低电平 |
| 模拟输入       | 模拟输入   | GPIO无效，引脚直接接入内部ADC            |
| 开漏输出       | 数字输出   | 可输出引脚电平，高电平为高阻态，低电平接VSS |
| 推挽输出       | 数字输出   | 可输出引脚电平，高电平接VDD，低电平接VSS |
| 复用开漏输出   | 数字输出   | 由片上外设控制，高电平为高阻态，低电平接VSS |
| 复用推挽输出   | 数字输出   | 由片上外设控制，高电平接VDD，低电平接VSS |

><img src="./STM32F103学习笔记.assets/1-3GPIO模式.png" width="67%">

#### ✏ GPIO配置常用函数

> <img src="./STM32F103学习笔记.assets/1-4GPIO配置常用函数1.png" width="67%">

> <img src="./STM32F103学习笔记.assets/1-5GPIO配置常用函数2.jpeg" width="67%">

#### ✏ 点亮一个LED灯

``` c
#include "stm32f10x.h"                  // Device header

/**
  * 函    数：LED初始化
  * 参    数：无
  * 返 回 值：无
  */
void LED_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);		//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);						//将PA1引脚初始化为推挽输出
	
	/*设置GPIO初始化后的默认电平*/
	GPIO_SetBits(GPIOA, GPIO_Pin_1);				//设置PA1引脚为高电平
}

/**
  * 函    数：LED开启
  * 参    数：无
  * 返 回 值：无
  */
void LED_ON(void)
{
	GPIO_ResetBits(GPIOA, GPIO_Pin_1);		//设置PA1引脚为低电平
}

/**
  * 函    数：LED关闭
  * 参    数：无
  * 返 回 值：无
  */
void LED_OFF(void)
{
	GPIO_SetBits(GPIOA, GPIO_Pin_1);		//设置PA1引脚为高电平
}
```

## 😎 外部中断控制

#### 😎 中断系统

- **中断：**在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行，也就是说***<u>发生事件后跳转到对应的程序执行完回来</u>***。
- **中断优先级：**当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源，也就是***<u>排队</u>***。
- **中断嵌套：**当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回，也就是***<u>可以打断函数的中断，优先执行</u>***。

> <img src="./STM32F103学习笔记.assets/2-1中断执行流程.png">

#### 😎 STM32F103中断

- ***<u>68</u>***个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设
- 使用NVIC统一管理中断，每个中断通道都拥有***<u>16</u>***个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级，也就是***<u>NVIC控制中断优先级</u>***。

> <img src="./STM32F103学习笔记.assets/2-2中断表.png">

#### 😎 外部中断触发顺序

- AFIO为***中断引角选择***，主要用于处理***引脚复用***之类的情况

- EXTI为***申请中断***，就像***学生举手打报告说我要做某件事一样***，向NVIC说明要进行中断了

- NVIC为***处理中断申请***，就像***秘书处理一些申请，把申请按照紧急程度排序一样***，用于跟CPU说你需要处理什么事情，而***CPU只需要埋头苦干***😭就可以

  > <img src="./STM32F103学习笔记.assets/2-3中断基本结构.png" style="zoom:50%;" >

#### 😎 NVIC中断优先级选择

- NVIC的中断优先级由优先级寄存器的***<u>4位（0~15）</u>***决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级

- 抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队

| 分组方式 | 抢占优先级（插队） | 响应优先级（排队） |
| :------: | :--------: | :--------: |
|  分组0   | 0位, 取值为0 | 4位, 取值为0~15 |
|  分组1   | 1位, 取值为0~1 | 3位, 取值为0~7 |
|  分组2   | 2位, 取值为0~3 | 2位, 取值为0~3 |
|  分组3   | 3位, 取值为0~7 | 1位, 取值为0~1 |
|  分组4   | 4位, 取值为0~15 | 0位, 取值为0 |

> <img src="./STM32F103学习笔记.assets/2-4中断优先级选择.png" style="zoom:50%;" >

#### 😎 EXTI外部中断

- EXTI（Extern Interrupt）外部中断
- EXTI可以***<u>检测引脚电平变化，申请中断</u>***
- 支持的触发方式：上升沿/下降沿/双边沿/软件触发
- 支持的GPIO口：所有GPIO口，但***<u>相同的Pin不能同时触发中断</u>***，比如***<u>PA0和PB0</u>***就不行
- 通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒
- 触发响应方式：中断响应/事件响应，事件响应就是不进去CPU，直接触发ADC/DMA

> <img src="./STM32F103学习笔记.assets/2-5外部中断框图.png" style="zoom:50%;" >

#### 😎 AFIO中断引脚选择

- AFIO主要用于***<u>引脚复用功能的选择和重定义</u>***，通俗来讲就是***<u>去选择哪个引脚作为中断</u>***
- 在STM32中，AFIO主要完成两个任务：***<u>复用功能引脚重映射、中断引脚选择</u>***

#### 😎 外部中断配置常用函数

> <img src="./STM32F103学习笔记.assets/2-6配置外部中断函数1.png">
>
> <img src="./STM32F103学习笔记.assets/2-6配置外部中断函数2.png">
>
> <img src="./STM32F103学习笔记.assets/2-6配置外部中断函数3.png">

#### 😎 对射式红外传感器计次

``` c
#include "stm32f10x.h"                  // Device header

uint16_t CountSensor_Count;				//全局变量，用于计数

/**
  * 函    数：计数传感器初始化
  * 参    数：无
  * 返 回 值：无
  */
void CountSensor_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		//开启GPIOB的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);		//开启AFIO的时钟，外部中断必须开启AFIO的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);						//将PB14引脚初始化为上拉输入
	
	/*AFIO选择中断引脚*/
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);//将外部中断的14号线映射到GPIOB，即选择PB14为外部中断引脚
	
	/*EXTI初始化*/
	EXTI_InitTypeDef EXTI_InitStructure;						//定义结构体变量
	EXTI_InitStructure.EXTI_Line = EXTI_Line14;					//选择配置外部中断的14号线
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;					//指定外部中断线使能
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;			//指定外部中断线为中断模式
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;		//指定外部中断线为下降沿触发
	EXTI_Init(&EXTI_InitStructure);								//将结构体变量交给EXTI_Init，配置EXTI外设
	
	/*NVIC中断分组*/
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);				//配置NVIC为分组2
																//即抢占优先级范围：0~3，响应优先级范围：0~3
																//此分组配置在整个工程中仅需调用一次
																//若有多个中断，可以把此代码放在main函数内，while循环之前
																//若调用多次配置分组的代码，则后执行的配置会覆盖先执行的配置
	
	/*NVIC配置*/
	NVIC_InitTypeDef NVIC_InitStructure;						//定义结构体变量
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;		//选择配置NVIC的EXTI15_10线
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				//指定NVIC线路使能
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;	//指定NVIC线路的抢占优先级为1
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;			//指定NVIC线路的响应优先级为1
	NVIC_Init(&NVIC_InitStructure);								//将结构体变量交给NVIC_Init，配置NVIC外设
}

/**
  * 函    数：获取计数传感器的计数值
  * 参    数：无
  * 返 回 值：计数值，范围：0~65535
  */
uint16_t CountSensor_Get(void)
{
	return CountSensor_Count;
}

/**
  * 函    数：EXTI15_10外部中断函数
  * 参    数：无
  * 返 回 值：无
  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行
  *           函数名为预留的指定名称，可以从启动文件复制
  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入
  */
void EXTI15_10_IRQHandler(void)
{
	if (EXTI_GetITStatus(EXTI_Line14) == SET)		//判断是否是外部中断14号线触发的中断
	{
		/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/
		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14) == 0)
		{
			CountSensor_Count ++;					//计数值自增一次
		}
		EXTI_ClearITPendingBit(EXTI_Line14);		//清除外部中断14号线的中断标志位
													//中断标志位必须清除
													//否则中断将连续不断地触发，导致主程序卡死
	}
}

```

